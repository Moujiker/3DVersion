#include "depthMap.h"
#include <iostream>
#include <fstream>
#include <ostream>
#include "utility.h"
#include <iostream>
#include <fstream>
#include <cstring>
#include <algorithm>
#include "dirent.h"

using namespace std;

depthMap::depthMap(size_t width, size_t height):
m_width(width),
m_height(height)
{
}

depthMap::~depthMap()
{
}

bool depthMap::writeDepthToMeshfile(const char* fileName, const unsigned char* depthData, const unsigned char* colorData, bool cullBlack, unsigned int minMM /*= 720*/, unsigned int maxMM /*= 900*/)
{
	float minX = -1.0f, maxX = 1.0f, minY = 1.0f, maxY = -1.0f, minZ = 0.0f, maxZ = 1.0f;
	ofstream  os;
	os.open(fileName, ios::out);
	int numPixels = m_width * m_height;
	int currPixel = 1;
	os << "#Generated by Depth2Mesh\n";
	while (currPixel <= numPixels)
	{
		unsigned char z = *(depthData++);
		if (!(cullBlack && z == 0))
		{
			double cx = 313.68782938, cy = 259.01834898, fx_inv = 1 / 526.37013657, fy_inv = fx_inv;
			double u = currPixel > m_width ? (currPixel - (currPixel / m_width) * m_width) : currPixel;
			double v = currPixel > m_width ? (currPixel / m_width) : 0.0f;

			double z_in_mm = LinnerInterpolate(minMM, maxMM, z / 255.0);

			double vx = z_in_mm * (u - cx) * fx_inv;
			double vy = -z_in_mm * (v - cy) * fy_inv;
			double vz = z_in_mm;

			os << vx;
			os << "\t";
			os << vy;
			os << "\t";
			os << vz;
			os << "\n";
			/*os << interpolate(minX, maxX, (currPixel > m_width ? (currPixel - (currPixel / m_width) * m_width) / (float)m_width : currPixel / (float)m_width));
			os << "\t";
			os << interpolate(minY, maxY, (currPixel > m_width ? (currPixel / m_width) / (float)height : 0.0f));
			os << "\t";
			os << interpolate(minZ, maxZ, z / 255.0f);
			os << "\n";*/
		}
		++currPixel;
	}
	os.close();
	return os.good();
}


void depthMap::depth2model(int index)
{
	cv::Mat_<double> currentDepth = m_vecDepthmaps.at(index);
	cv::Mat img = m_vecImages.at(index);
	cv::Mat currentImg = img.clone();
	cv::resize(currentImg, currentImg, cv::Size(currentDepth.cols, currentDepth.rows));

	std::ofstream ofs("points.ply");
	ofs << "ply \n format ascii 1.0 \n element vertex " << currentDepth.rows * currentDepth.cols << " \n property float x \n property float y \n property float z \n property uchar diffuse_red \n property uchar diffuse_green \n property uchar diffuse_blue \n end_header" << std::endl;

	for (int x = 0; x < currentDepth.rows; x++) {
		for (int y = 0; y < currentDepth.cols; y++) {
			Eigen::Vector3d ptX = m_keyFrameSel.get3Dpoint(index, x, y, currentDepth.at<double>(x, y));

			ofs << ptX(0) << " " << ptX(1) << " " << ptX(2) << " ";
			ofs << (int)currentImg.at<cv::Vec3b>(x, y)[2] << " " << (int)currentImg.at<cv::Vec3b>(x, y)[1] << " " << (int)currentImg.at<cv::Vec3b>(x, y)[0] << std::endl;
		}
	}

	ofs.close();
}

//project 3d model with a single view of param
cv::Mat_<double> depthMap::model2depth(std::string modelName, int index) {
	cv::Mat currentImg = m_vecImages.at(index);
	CCamera currentParam = m_keyFrameSel.parameters.at(index);
	cv::Mat_<double> depth = cv::Mat::zeros(currentImg.rows, currentImg.cols, CV_32F);

	int totalVertex = 0;
	char str[100];
	std::ifstream ifs(modelName);
	ifs >> str;
	while (strcmp(str, "vertex") != 0){
		ifs >> str;
	}
	ifs >> totalVertex;
	while (strcmp(str, "end_header") != 0) {
		ifs >> str;
	}

	std::string strs;
	int minn = 99999, maxn = 0;
	while (totalVertex--) {
		Eigen::Vector4d pX = Eigen::Vector4d::Ones(4, 1);
		for (int i = 0; i < 3; i++) {
			ifs >> pX(i, 0);
		}
		std::getline(ifs, strs);
		Eigen::Vector3d px = currentParam.getP() * pX;

		int y = px(0, 0) / px(2, 0);
		int x = px(1, 0) / px(2, 0);
		if (x >= 0 && x < currentImg.rows && y >= 0 && y < currentImg.cols) {
			depth.at<double>(x, y) = px(2, 0);

			minn = min(minn, (int)px(2, 0));
			maxn = max(maxn, (int)px(2, 0));
		}
	}
	ifs.close();

	for (int i = 0; i < currentImg.rows; i++) {
		for (int j = 0; j < currentImg.cols; j++) {
			depth.at<double>(i, j) = (depth.at<double>(i, j) - minn) * 255 / (maxn - minn);
		}
	}
	//	cv::imwrite("depth.jpg", depth);

	return depth;
}

void depthMap::readDepthmaps()
{
	int totalNum = m_keyFrameSel.parameters.size();
	for (int i = 0; i < totalNum; i++)
	{
		cv::Mat_<double> depth;
		m_vecDepthmaps.push_back(depth);
	}

	int idx = 0;
	std::vector<std::string> fileList;
	DIR *dp;//承ミ戈僻ǐ夹
	struct dirent *dirp;
	if ((dp = opendir((m_dataPath + "/maskDepthmaps").c_str())) == NULL)
	{
		std::cout << "Error(" << errno << ") opening " << m_dataPath << "/maskDepthmaps" << std::endl;
		return;
	}
	while ((dirp = readdir(dp)) != NULL)
	{
		fileList.push_back(std::string(dirp->d_name));//N戈僻īM郎爪W瘠Jvector
	}
	closedir(dp);//闽超戈僻ǐ夹

	for (auto fileinfo : fileList)
	{
		std::string name = fileinfo;

		sscanf(name.c_str(), "%d.jpg", &idx);

		cv::Mat_<double> depth = cv::imread(fileinfo.c_str(), 0);
		m_vecDepthmaps.at(idx) = depth;
	}
}

void depthMap::readImgs()
{
	std::vector<std::string> fileList;
	DIR *dp;
	struct dirent *dirp;
	if ((dp = opendir((m_dataPath + "/maskPic").c_str())) == NULL) {
		std::cout << "Error(" << errno << ") opening " << m_dataPath << "/maskDepthmaps" << std::endl;
		return;
	}
	while ((dirp = readdir(dp)) != NULL)
	{
		fileList.push_back(std::string(dirp->d_name));
	}
	closedir(dp);

	for each (auto fileinfo in fileList)
	{
		cv::Mat img = cv::imread(fileinfo.c_str());
		m_vecImages.push_back(img);
	}
}

void depthMap::test(std::string dataDir)
{
	m_dataPath = dataDir;

	m_keyFrameSel.dataPath = dataDir;
	m_keyFrameSel.readParams();

	readDepthmaps();
	readImgs();
}

void depthMap::depthFusion() {
	/*		cv::Mat_<double> currentDepth;
	cv::Mat img;
	cv::Mat currentImg;
	char str[100];
	std::ofstream ofs;

	for (int index  = 0; index < depthmaps.size(); index++) {
	if (depthmaps.at(index).rows <=0 ) continue;

	currentDepth = depthmaps.at(index);
	img = imgs.at(index);
	currentImg = img.clone();
	cv::resize(currentImg, currentImg, cv::Size(currentDepth.cols, currentDepth.rows));


	sprintf(str, "models/%08d_points.ply", index);
	ofs.open(str);
	ofs << "ply \n format ascii 1.0 \n element vertex " << currentDepth.rows * currentDepth.cols << " \n property float x \n property float y \n property float z \n property uchar diffuse_red \n property uchar diffuse_green \n property uchar diffuse_blue \n end_header" << std::endl;

	for (int x = 0; x < currentDepth.rows; x++) {
	for (int y = 0; y < currentDepth.cols; y++) {
	Eigen::Vector3d ptX = params.get3Dpoint(index, x, y, currentDepth.at<double>(x, y));

	ofs << ptX(0) << " " << ptX(1) << " " << ptX(2) << " ";
	ofs << (int)currentImg.at<cv::Vec3b>(x, y)[2] << " " << (int)currentImg.at<cv::Vec3b>(x, y)[1] << " " << (int)currentImg.at<cv::Vec3b>(x, y)[0] << std::endl;
	}
	}
	ofs.close();
	}
	*/
#if 1
	int index = 3;
	cv::Mat_<double> currentDepth = m_vecDepthmaps.at(index);
	cv::Mat img = m_vecImages.at(index);
	cv::Mat currentImg = img.clone();
	cv::resize(currentImg, currentImg, cv::Size(currentDepth.cols, currentDepth.rows));

	std::ofstream ofs("points.ply");
	ofs << "ply \n format ascii 1.0 \n element vertex " << currentDepth.rows * currentDepth.cols << " \n property float x \n property float y \n property float z \n property uchar diffuse_red \n property uchar diffuse_green \n property uchar diffuse_blue \n end_header" << std::endl;

	for (int x = 0; x < currentDepth.rows; x++) {
		for (int y = 0; y < currentDepth.cols; y++) {
			Eigen::Vector3d ptX = m_keyFrameSel.get3Dpoint(index, x, y, currentDepth.at<double>(x, y));

			ofs << ptX(0) << " " << ptX(1) << " " << ptX(2) << " ";
			ofs << (int)currentImg.at<cv::Vec3b>(x, y)[2] << " " << (int)currentImg.at<cv::Vec3b>(x, y)[1] << " " << (int)currentImg.at<cv::Vec3b>(x, y)[0] << std::endl;
		}
	}
	/*
	index = 50;
	currentDepth = depthmaps.at(index);
	img = imgs.at(index);
	currentImg = img.clone();
	cv::resize(currentImg, currentImg, cv::Size(currentDepth.cols, currentDepth.rows));

	Eigen::Matrix3d betweenR = params.parameters.at(index).R.inverse() * params.parameters.at(3).R;

	for (int x = 0; x < currentDepth.rows; x++) {
	for (int y = 0; y < currentDepth.cols; y++) {
	Eigen::Vector3d ptX = params.get3Dpoint(3, x, y, currentDepth.at<double>(x, y));
	ptX = betweenR * ptX;

	ofs << ptX(0) << " " << ptX(1) << " " << ptX(2) << " ";
	ofs << (int)currentImg.at<cv::Vec3b>(x, y)[2] << " " << (int)currentImg.at<cv::Vec3b>(x, y)[1] << " " << (int)currentImg.at<cv::Vec3b>(x, y)[0] << std::endl;
	}
	}

	ofs.close();*/
#endif
}

void depthMap::Depth2PointCloud(cv::Mat_<double> imDepth, std::string filePath)
{
	//-- 结构光相机IR传感器内参
	float fx = 525.0;
	float fy = 525.0;
	float cx = 319.5;
	float cy = 239.5;
	struct Point
	{
		float m_x, m_y, m_z;
	};

	std::vector<Point> mypoint;
	for (int i = 0; i < imDepth.rows; i++) 
	{
		for (int j = 0; j < imDepth.cols; j++) 
		{
			if (imDepth.at<unsigned short>(i, j) != 0) 
			{
				unsigned short Zw = imDepth.at<unsigned short>(i, j);
				float Xw, Yw, Zw;
				Xw = Yw = Zw = 0;

				Xw = (j - cx) *  Zw / fx;
				Yw = (i - cy) * Zw / fy;
				Zw = (float)(Zw / 1000.0);

				Point myp;
				myp.m_x = Xw;
				myp.m_y = Yw;
				myp.m_z = Zw;
				mypoint.push_back(myp);
			}
		}
	}

	std::ofstream os(filePath.c_str());
	int num_p = mypoint.size();
	os << "ply" << "\n" << "format ascii 1.0" << "\n";
	os << "element vertex " << num_p << "\n";
	os << "property float x" << "\n";
	os << "property float y" << "\n";
	os << "property float z" << "\n";
	//add************2017/6/28
	os << "property uchar red" << "\n";
	os << "property uchar green" << "\n";
	os << "property uchar blue" << "\n";
	//add************2017/6/28
	os << "end_header" << "\n";

	std::cout << mypoint.size()<<std::endl;

// 	for (int i = 0; i < mypoint.size(); i++)  {
// 		//-- 这里可以增加RGB信息到ply文件中
// 		//        os<<mypoint[i].x<<" "<<mypoint[i].y<<" "<<mypoint[i].z<<" "<< mypoint[i].r<<" "<<\
// 				//            mypoint[i].g<<" "<<mypoint[i].b<<endl;
// 		os << mypoint[i].x << "     " << mypoint[i].y << "      " << mypoint[i].z << "\n";
// 	}
	os.close();
}
